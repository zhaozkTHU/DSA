# 4.3 kth

## 构思、原理与实现要点

本题为优先级队列的应用。由于本题限制了接口，所以需要使用特殊的方法来排序或比较大小，使用运算符重载较为方便。

首先需要将三个数组进行排序。首先最小方案一定是`a[0]+b[0]+c[0]`，而 $a[i] + b[j] + c[k]$ 的方案一定不优于 $a[u] + b[v] + c[w]$，如果 $u \le i, v \le j, w \le k$。那么就使用优先级队列，每次都删去最小的，再将后继节点添加即可，这些后继节点一定是大于被删去的。

## 问题解决过程

在插入后继元素时，可能会发生重复。一个元素可以由多个前驱生成。为了避免重复，我尝试了三种方法。

- 使用数组记录

  开辟一个数组，将所有使用过的元素记录下来。但是一共可能会有`n*n*n`种重复元素，将会导致内存超限。

- 使用散列函数

  使用hashmap来存储使用过的元素。但hashmap实现较为复杂，且较重，于是开始寻找更加轻量级的方法来规避重复。

- 固定前驱元素

  发生重复是因为有些元素有多个前驱元素。使用好方法使每个元素固定前驱，即可从根源上避免重复。

  - 对于 $j = 0, k = 0$ 的方案，三种后继均插入优先级队列。
  
  - 否则对于 $k = 0$ 的方案，只加入 $(i, j + 1, k)$ 和 $(i, j, k + 1)$ 两种后继

  - 其他情况，只加入 $(i, j, k + 1)$ 的后继。

  如此规定插入元素，即可避免重复

## 复杂度分析

对三个数组进行排序，时间复杂度为$O(n\log n)$。

操作过程中，会去除k个元素，最差添加3k个元素，时间复杂度为$O(k\log n)$。

空间复杂度为$O(k)$