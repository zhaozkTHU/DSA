# LAB3 BBST

## 实现过程及复杂度分析

我实现了AVL树以及splay树。首先建立二叉搜索树类`BST`，继承自二叉树类`BinTree`。再由二叉搜索树类继承出`AVL`以及`Splay`树，统一接口。具体实现过程参考了老师的讲义以及示例代码。两种树的`zig`和`zag`操作都使用`connect34`重构。

AVL插入、删除、查询复杂度均为$O(\log n)$

Splay的每次伸展操作由势能计算分摊复杂度为$O(\log n)$

## 测例设计思路

测例有多种特征：操作次数、不同操作所占比例、操作分布特征。不同的操作次数也即不同的规模，很明显会对数据结构产生不同的影响。不同操作所占比例也即ABC四种操作的分布情况，两种树可能在插入、删除和查询的性能不同。操作分布特征可以为随机分布，亦可以为再插入后多次使用。

## 测例生成方式

由于不能插入相同节点且删除必须删除已经存在的节点，可以使用c++标准库中的`set<int>`来进行存储。后根据不同的特征来随机生成不同的数据。

## 性能描述及原因分析

- 操作分布完全随机

| n=100,000 | 三种操作比例相同 | 插入较多 | 查询较多 |
| --------- | ---------------- | -------- | -------- |
| AVL       | 0.033023         | 0.044810 | 0.030764 |
| Splay     | 0.079462         | 0.100859 | 0.071662 |

可以看出，在操作分布完全随机的情况下，AVL比Splay快约一倍左右，在数据规模的较小的情况下也是类似情况。这是因为AVL是严格平衡的，更适合比较随机的情况。而splay更不平衡，它的优点在每次查询后上移也没有体现出来。所以在这种情况下AVL更优。

- 数据在插入后迅速被查询

| n=100,000 | 插入后3次查询 | 插入后10次查询 | 插入后30次查询 |
| --------- | ------------- | -------------- | -------------- |
| AVL       | 0.029701      | 0.023081       | 0.020276       |
| Splay     | 0.040917      | 0.024950       | 0.015704       |

可以看出，在查询次数越多的情况下，Splay越快，而AVL则比较稳定，随查询次数变化较少。这也是Splay树的特点造成的，在每次查询后，被查询到的节点就会上移，再次查询时时间会大大减少。