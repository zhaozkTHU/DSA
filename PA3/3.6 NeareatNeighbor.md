# 3.6 NeareatNeighbor

## 构思、原理与实现要点

本题考查kd-tree的构建与查询，与老师上课讲的矩形查询略有不同，但基本思路没有区别。

首先是建树，建树即没一次分割都按照不同的维度进行排序并二分，取中间节点并将两侧的节点置于两个子树。但在理论上来说，使用`nth_element`时间复杂度将会更短，实现部分排序即可，但使用`qsort`复杂度也符合要求，且`nth_element`在`algorithm`库中，无法使用。本题特殊在于，叶节点可以存储多个节点来提高效率。将多个节点放在一个叶节点，可以保证内存连续性，能提高读取效率，并且可以减少递归次数，大大提高时间。

在查询时，计算待查询点到分界线的距离，若距离大于当前的最小距离，则无需继续向下递归。当到达叶节点时，直接遍历即可。

## 问题解决过程

最开始我是构建了纯粹的kd-tree，五成测的最后几个点时间超限，后来将叶节点存储了最多十个节点，成功通过九成测。

## 复杂度估算

### 时间复杂度

建树，使用`sort`，复杂度为$O(n\log^2(n))$。

查询，平均复杂度为$O(\log n)$

### 空间复杂度

共有n个节点，空间复杂度为$O(n)$