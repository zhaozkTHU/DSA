# LAB2 HashFun

## 不同哈希策略的实现

### `allplus_hashing`

此哈希函数将会使用字符串的所有信息，但将字符串不均匀地映射到哈希表中。具体实现方式是将字符串每个字符枚举并将其ascii值相加，再取模。此哈希函数的优点是充分使用了字符串的所有信息，缺点是不均匀，如果两个字符串相差不大，那么他们的哈希值将会非常接近。

### `code_hashing`

此哈希函数是上课所讲的`hashcode`方法。具体实现方法是在每次加单个字符前，将整体数值之和进行移位，这将大大提高结果的随机性，并且使用了所有的字符，是一种优秀的哈希函数。

### `double_square_probe`

```c++
void double_square_probe::init() {
    time = 0;
}
int double_square_probe::operator()(hash_entry *Table, int table_size, int last_choice) {
    int res = 0;
    time += 1;
    if (time % 2 != 0) {
        res = (last_choice + (time / 2) * (time / 2) + (time / 2 + 1) * (time / 2 + 1)) % table_size;
    }
    else {
        res = (last_choice - 2 * (time / 2) * (time / 2)) % table_size;
    }
    if (res < 0) res += table_size;
    return res;
}
```

双向平方试探。再每次冲突后，依次加或减n^2^，知道寻找到空的桶。`time`为重复次数，根据`time`的奇偶性执行加减，并最终得出正确答案。需要注意的是，每次计算是基于上一次计算的结果，所以需要进行额外的操作来抵消上一次的加减，并且双向平方试探最终的结果极有可能是负数，需要对负数进行处理，否则会出现`segmentation fault`。

### `overflow_probe`

```c++
void overflow_probe::init() {
    overflow = false;
}
int overflow_probe::operator()(hash_entry *Table, int table_size, int last_choice) {
    if (overflow) {
        return last_choice + 1;
    }
    else {
        overflow = true;
        return table_size / 2 + 1;
    }
}
```

公共溢出区策略。每次冲突都将冲突放入溢出区中，若该溢出区已被占用，则继续向后寻找。`bool overflow`表示是否进入溢出区。若为`false`，则将结果设为溢出区的开始位置。若已经溢出，则直接取下一个即可。需要注意的是，由于本策略将区域的一半大小设为公共溢出区，需要对`hashing_strategy`传入的`table_size`进行修改。

```c++
int new_table_size = dynamic_cast<overflow_probe *>(my_collision) == nullptr ? table_size : table_size / 2;
```

使用`dynamic_cast`来判断冲突策略是否为`overflow_probe`

## 进行测试

由于只允许使用3组数据并且需要考虑不同数据规模、不同的插入/查询操作比例、插入和查询的不同分布方式，将三种不同的区别整合到三组数据中。三种不同的区别构造方法如下

- **规模较大、规模较小**。规模较大是指插入的值与`table_size`为同一数量级，此情况对应出现大量哈希碰撞，便于比较不同的哈希函数。规模较小是指插入的值远小于`table_size`，桶中的使用较为稀疏，哈希碰撞较少。
- **插入查询比例**。经猜测，不同的策略组合可能插入和查询的时间有区别，便将比例分为三种，大于、小于、等于来比较不同的比例之间的区别。
- **不同分布方式**。在实际生产使用中，哈希表可能有两种使用情况，一种是先插入所有的数据并进行查询，一种是在使用的过程中不断地更新。于是构造两种分布方式：集中分布与均匀分布来模拟现实中地情况。


## 分析结果

### “好”和“坏”的哈希函数的性能比较情况如何？为什么是这样？

好哈希函数在数据规模较大的情况下远优于坏哈希函数，较小时差距缩小但仍有较大差距。好哈希函数的随机性更加优秀，将有更低的概率发生哈希碰撞。较小时由于数据较少，空间足够大，哈希碰撞概率都会幅度减少，差距缩小。

### 线性试探和双向平方试探的性能比较情况如何？为什么是这样？

在坏哈希函数中，双向平方远由于线性试探。好哈希函数中，两者接近。

两种试探都只会在发生哈希碰撞时使用。坏哈希函数将会经常发生碰撞，两者使用次数较多，差距更加明显。而好哈希函数本身碰撞概率较低，试探的优势无法体现。

### 在测试数据中，开放散列(公共溢出区)和封闭散列(使用试探链)的比较情况如何，谁占优势？在你的测试结果中不占优势的处理策略，处理什么样的实际数据时会更适合使用？

在数据较大时，封闭散列更占优势。数据较少时，开放散列更占优势。

数据较大时，由于开放散列将所有的碰撞数据都置入公共溢出区，导致溢出区非常大，而每次在溢出区查询都将占用$O(n)$的时间复杂度，远慢与开放散列。而数据较小，溢出区占用不多，查询次数不多，并且可能由于内存连续，导致时间略小于封闭散列。

开放散列处理数据较少，碰撞概率较低的实际数据会更适合使用。

### 设计哈希函数时，我们往往假定字符串每个位置上出现字符集内每个字符的概率都是相等的，但实际的数据集往往并不满足这一点。这可能造成什么影响？

在数据集中，每个字符都是字母和数字，导致单个字符的ascii的值集中在某一区域，并且常用的字母使用概率会很高。如果使用了坏的哈希函数，计算出的散列值将会集中在某一区域，导致碰撞概率大大增加，效率显著降低。优秀的哈希函数将会降低造成的影响。

### 实验框架的哈希表容量一定，如果希望哈希表能够做到动态扩容和缩容，你准备如何实现？(介绍思路即可)

- 类似于`vector`的动态扩容或缩容。当使用量占总大小的比例高于或低于一定比例时，进行扩容或缩容。但在操作完成后，需要对每一项重新计算散列值并重新插入。
- 多个哈希表并联。若插入时陷入死循环或比例过高，则构造新的哈希表，插入或查询都依次询问下去。若比例过低，则删除后方的哈希表，并将表中的数据插入前置的哈希表。
