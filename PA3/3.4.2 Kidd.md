# 3.4.2 Kidd

## 构思、原理与实现要点

本题是经典的线段树应用。由于数据巨大，因此要特别小心内存空间的使用，动态开辟子树来节省内存。

## 问题解决过程

线段树老师在课上已经讲的很清楚了，主要问题还是内存空间的节省。我采取了一下几种方法来节省内存空间：


- 动态开辟子树
  
  在上课时，老师对线段树的演示是先构造出一个完整的线段树再对其进行操作。本题数据规模较大，很明显这样做会时间超限，可以想到动态开辟子树。在查询或进行操作时，如果需要左子树或右子树，再进行构造，可以节省不少空间。

- 数据类型的存储
  
  我构造的线段树包括`lazy`,`value`以及两个子树的指针。在存储时`lazy`的值不会超过翻牌的次数，使用`uint`即可，但`value`可能包括所有的卡牌之和，需要使用`unsigned long long`存储

- 减少子树的构造数量

  如果不进行优化，将会有很多的子树是没有必要开的。例如，如果树的`value`为0，那么在接下来的查询中，没有必要再二分继续查询，直接通过`lazy`算出正确答案即可。

## 复杂度估算

关于本算法的复杂度，课本上已经给出了详细的推导过程。

构建树的时间复杂度为$O(n\log n)$

单步查询或修改的时间复杂度为$O(\log n)$，总时间复杂度为$O(m\log n)$

在每一次操作时，最多只会开$\log n$的新节点，总空间复杂度为$O(m\log n)$，在本题n非常大的情况下，$O(m \log n)$是远小于未作优化情况下$O(n \log n)$的