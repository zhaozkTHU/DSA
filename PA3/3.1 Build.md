# 3.1 Build

## 构思、原理与实现要点

本题是基本的多叉树的构建与操作。一般来说，构建多叉树有两种方式，将子节点存储为链表，或按照课上讲的方法将多叉树转化为二叉树。两种方式再本题中操作的复杂度均为$O(cost)$，我采用的是将子节点存储为链表。

本题还需要查询子树的高度和规模。在完成初始构建后，递归求得所有节点的高度和规模。在每次移动子树后，都要对其祖先节点进行更新。

- 子树规模

  子树规模更新时，直接进行递归，加上或减去添加或移除的子树的规模，并不复杂

- 子树高度

  子树高度更新时，需分为两种情况

  - 添加了子树。若添加的子树并非原来最大的，不需要进行更新。若为最大的，则需要更新，并对祖先节点更新

  - 移除子树。若移除的子树为源节点最高的子树，则需要重新遍历并更新祖先节点。

## 问题解决过程

~~感觉本题表述不清~~最开始，我是源子树和目的子树一起求，发现会出现re，后来询问他人，才得知`rank`是将子树移除后的排位，需先将子树移除，再寻找下一个子树。

## 复杂度估算

节点数为$n$，边数为$n-1$

### 时间复杂度

构建子树时，将一个节点置入另一个节点子节点为$O(1)$，总时间复杂度为

$$O(n)$$

移动子树时，会对链表进行寻址，单次操作复杂度为$O(cost)$，复杂度为

$$O(m*cost)$$

### 空间复杂度

每个节点为O(1)的空间复杂度，总复杂度为

$$O(n)$$