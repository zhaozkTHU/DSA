# 3.2 NotFound

## 构思、原理与实现要点

本题所有的数据都为0或1，因此很容易想到需要使用c++的位运算。由于长度较大，所以需要压缩空间。如果使用`int`存储0或1，需要32位，使用`bool`需要8位，而0或1只需1位就可以存储。而c++并没有只有1位的基本类型。所以我构思将32位合在一起组成一个`unsigned`，空间变为了1/32或1/8

## 问题解决过程

在构造`Bit`类时，没有遇到问题。但在五成测时，遇到了时间超限。仔细观察代码与题目，发现在枚举所给字符串时，每一个字符串都是由前一个字符串去掉最高位，加上最低位组成的，便可以通过递推得到。


## 复杂度估算

### 时间复杂度

设答案最长为k，则字串共有n-k个，由鸽巢原理可知，当$2^k>n-k$时，一定会有答案。本题中k为24，即无论如何答案长度不超过24。复杂度为

$$O(\sum\limits_{k=1}^{24}(n-k))=O(n)$$

### 空间复杂度

一共使用两个`Bit`类，每个类大小为`MAX_CAPACITY`。复杂度为

$$O(2*\text{MAX\_CAPACITY}) = O(1)$$